<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Thread Model · Cats Effect</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Cats effect is a powerful tool for creating and reasoning about highly"/><meta name="docsearch:version" content="3.x"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Thread Model · Cats Effect"/><meta property="og:type" content="website"/><meta property="og:url" content="https://typelevel.org/cats-effect/"/><meta property="og:description" content="Cats effect is a powerful tool for creating and reasoning about highly"/><meta property="og:image" content="https://typelevel.org/cats-effect/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://typelevel.org/cats-effect/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/cats-effect/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/cats-effect/js/scrollSpy.js"></script><link rel="stylesheet" href="/cats-effect/css/main.css"/><script src="/cats-effect/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/cats-effect/"><img class="logo" src="/cats-effect/img/cats-effect-logo.svg" alt="Cats Effect"/><h2 class="headerTitleWithLogo">Cats Effect</h2></a><a href="/cats-effect/versions"><h3>3.x</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/cats-effect/docs/getting-started" target="_self">Docs</a></li><li class=""><a href="/cats-effect/api/3.x" target="_self">API</a></li><li class=""><a target="_self"></a></li><li class=""><a href="https://github.com/typelevel/cats-effect" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Overview</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Overview<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/cats-effect/docs/getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/tutorial">Tutorial</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/migration-guide">Migration Guide</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/cats-effect/docs/thread-model">Thread Model</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/schedulers">Schedulers</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Typeclasses<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses">Overview</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/monadcancel">MonadCancel</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/spawn">Spawn</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/unique">Unique</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/clock">Clock</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/concurrent">Concurrent</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/temporal">Temporal</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/sync">Sync</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/async">Async</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Standard Library<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/countdown-latch">Count Down Latch</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/cyclic-barrier">Cyclic Barrier</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/deferred">Deferred</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/dequeue">Dequeue</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/dispatcher">Dispatcher</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/hotswap">Hotswap</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/pqueue">Priority Queue</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/queue">Queue</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/ref">Ref</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/resource">Resource</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/std/supervisor">Supervisor</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Thread Model</h1></header><article><div><span><p>Cats effect is a powerful tool for creating and reasoning about highly
concurrent systems. However, to utilize it effectively it is necessary to
understand something about the underlying thread model and how fibers are
scheduled on top of it.</p>
<p>This section also discusses cats effect 2 as the comparison is instructive and
many of our users are already at least somewhat familiar with it.</p>
<h2><a class="anchor" aria-hidden="true" id="high-level-goals"></a><a href="#high-level-goals" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>High-level goals</h2>
<p>The high-level goals of threading are covered in detail by <a href="https://gist.github.com/djspiewak/46b543800958cf61af6efa8e072bfd5c">Daniel's gist</a> so I'll
just give the executive summary. We are aiming for:</p>
<ul>
<li>A single thread pool of roughly the number of available processors for compute-based operations
(depending on your application you may get better performance by leaving one or two cores
free for GC, etc)</li>
<li>An unbounded, cached threadpool for blocking operations</li>
<li>1 or 2 high-priority threads for handling asynchronous I/O events, the handling of which should
immediately be shifted to the compute pool</li>
</ul>
<p>The goal of this is to minimize the number of expensive thread context shifts
and to maximize the amount of time that our compute pool is doing useful work.</p>
<p>It is also worth noting that <code>scala.concurrent.ExecutionContext.global</code> is a
poor choice for your compute pool as its fork-join design assumes that there
will be blocking operations performed on it and hence it allocates more threads.
In addition, there is no way to stop libraries on your classpath from scheduling
arbitrary code on it so it is a very unreliable basis for your compute pool.</p>
<h2><a class="anchor" aria-hidden="true" id="the-io-runloop"></a><a href="#the-io-runloop" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The IO runloop</h2>
<p>A simplified <code>IO</code> might look something like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IO</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">IO</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">B</span>] = <span class="hljs-type">FlatMap</span>(<span class="hljs-keyword">this</span>, f)
  
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unsafeRun</span></span>(): <span class="hljs-type">A</span> = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Pure</span>(a) =&gt; a
    <span class="hljs-keyword">case</span> <span class="hljs-type">Suspend</span>(thunk) =&gt; thunk()
    <span class="hljs-keyword">case</span> <span class="hljs-type">FlatMap</span>(io, f) =&gt; f(io.unsafeRun()).unsafeRun()
  }
}

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pure</span>[<span class="hljs-type">A</span>](<span class="hljs-params">a: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">IO</span>[<span class="hljs-type">A</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Suspend</span>[<span class="hljs-type">A</span>](<span class="hljs-params">thunk: (</span>) <span class="hljs-title">=&gt;</span> <span class="hljs-title">A</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">IO</span>[<span class="hljs-type">A</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlatMap</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](<span class="hljs-params">io: <span class="hljs-type">IO</span>[<span class="hljs-type">B</span>], f: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">IO</span>[<span class="hljs-type">A</span>]</span>
</code></pre>
<p>Of course this has no error handling, isn't stacksafe, doesn't support asynchronous effects, etc
but it's close enough for illustrative purposes. The key thing to note is that <code>unsafeRun()</code>
is a tightly CPU-bound loop evaluating different layers of <code>IO</code>. The situation is just the same
when we evaluate the real <code>IO</code> via one of the <code>unsafeRunX</code> methods or as part of an <code>IOApp</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="fibers"></a><a href="#fibers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fibers</h3>
<p>Of course we tend to have many logical threads of execution in our applications.
Cats effect trivially supports this via lightweight <code>Fiber</code>s, each of which is
an instance of the <code>IO</code> runloop. These are run <code>m:n</code> on the OS-level threads (so
there is no direct mapping between fibers and threads) and can be created via
<code>IO#start</code>, as well as various combinators like <code>IO#race</code>. It is important to
note that this is <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">cooperative
multi-tasking</a> (as
opposed to pre-emptive) so it is the responsibility of a fiber to yield control
of the CPU by suspending its runloop periodically. In practice this is rarely an
issue as fibers automatically yield at asynchronous boundaries (eg I/O) but it
does means that it is actually possible for a fiber to take control of a CPU
core and never give it back if it executes a tight CPU-bound loop like</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span></span>(n: <span class="hljs-type">BigInt</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">BigInt</span>] = n <span class="hljs-keyword">match</span> {
   <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-type">IO</span>.pure(<span class="hljs-number">1</span>)
   <span class="hljs-keyword">case</span> n =&gt; factorial(n<span class="hljs-number">-1</span>).flatMap {
      m =&gt; <span class="hljs-type">IO</span>.pure(m * n)
   }
}

factorial(<span class="hljs-number">10000</span>).unsafeRunSync()
</code></pre>
<p>If you have such a loop then you can insert a fairness boundary via <code>IO.shift</code>
(CE2 but has other potential side-effects) or <code>IO.cede</code> (CE3), which will give
another fiber an opportunity to run on the thread.</p>
<p>Note that the runloop-per-fiber model means that we obtain maximum performance
when all of our CPU threads are free to evaluate this runloop for one of our
<code>IO</code> fibers.</p>
<h3><a class="anchor" aria-hidden="true" id="thread-blocking"></a><a href="#thread-blocking" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Thread blocking</h3>
<p>A direct consequence of the above is that running blocking code on our compute
pool is <em>very</em> bad. If we're running on a node with 2 CPUs and we evaluate a
blocking call like <code>IO(Source.fromFile(path).getLines())</code> then for the duration
of that operation our capacity to evaluate <code>IO</code> fibers is <em>halved</em>. Run two such
operations at the same time and your application effectively stops until one of
those blocking calls completes.</p>
<p>The solution to this is to shift the execution of the blocking operation to our
unbounded, cached threadpool and then shift computation back to the compute pool
once the blocking call has completed.  We'll see code samples for this later as
it is quite different between CE2 and CE3.</p>
<h3><a class="anchor" aria-hidden="true" id="semantic-blocking"></a><a href="#semantic-blocking" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Semantic blocking</h3>
<p>Of course, we do also need the ability to tell fibers to wait for conditions to
be fulfilled. If we can't call thread blocking operations (eg Java/Scala builtin
locks, semaphores, etc) then what can we do? It seems we need a notion of
<em>semantic</em> blocking, where the execution of a fiber is suspended and control of
the thread it was running on is yielded.</p>
<p>Cats effect provides various APIs which have these semantics, such as
<code>IO.sleep(duration)</code>.  Indeed this is why you must never call
<code>IO(Thread.sleep(duration))</code> instead, as this is a thread blocking operation
whereas <code>IO.sleep</code> is only semantically blocking.</p>
<p>The building block for arbitrary semantic blocking is <code>Deferred</code>, which is a
purely functional promise that can only be completed once</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Deferred</span>[<span class="hljs-type">F</span>[_], <span class="hljs-title">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]
  
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complete</span></span>(a: <span class="hljs-type">A</span>): <span class="hljs-type">F</span>[<span class="hljs-type">Unit</span>]
}
</code></pre>
<p><code>Deferred#get</code> is semantically blocking until <code>Deferred#complete</code> is called and
cats effect provides many more semantically blocking abstractions like
semaphores that are built on top of this.</p>
<h2><a class="anchor" aria-hidden="true" id="summary-thus-far"></a><a href="#summary-thus-far" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary thus far</h2>
<p>So we've seen that best performance is achieved when we dedicate use of the compute pool
to evaluating <code>IO</code> fiber runloops and ensure that we shift <em>all</em> blocking operations
to a separate blocking threadpool. We've also seen that many things do not need to
block a thread at all - cats effect provides semantic blocking abstractions for waiting
for arbtirary conditions to be satisifed. Now it's time to see the details of how we achieve
this in cats effect 2 and 3.</p>
<h2><a class="anchor" aria-hidden="true" id="cats-effect-2"></a><a href="#cats-effect-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cats Effect 2</h2>
<p>CE2 <code>IOApp</code> provides a fixed execution context sized to the number of available
cores for us to use for compute-bound work. This maintains a global queue of
runnables awaiting scheduling. Several abstractions are provided to facilitate
shifting work to other pools.</p>
<h3><a class="anchor" aria-hidden="true" id="context-shift"></a><a href="#context-shift" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Context shift</h3>
<p><code>ContextShift</code> is a pure representation of a threadpool and looks a bit like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ContextShift</span>[<span class="hljs-type">F</span>[_]] </span>{

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shift</span></span>: <span class="hljs-type">F</span>[<span class="hljs-type">Unit</span>]

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalOn</span></span>[<span class="hljs-type">A</span>](ec: <span class="hljs-type">ExecutionContext</span>)(fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]

}
</code></pre>
<p>An instance of this will be backed by some thread pool. <code>IOApp</code>
provides an instance which is backed by the default compute pool it provides.</p>
<p><code>evalOn</code> allows us to shift an operation onto another pool and have the
continuation be automatically shifted back eg</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">CS</span>.evalOn(blockingPool)(
    <span class="hljs-type">IO</span>(println(<span class="hljs-string">"I run on the blocking pool"</span>))
  ) &gt;&gt; <span class="hljs-type">IO</span>(println(<span class="hljs-string">"I am shifted onto the pool that CS represents"</span>))
</code></pre>
<p><code>shift</code> is a uni-directional shift of thread pool so that the continuation runs on the pool that
the <code>ContextShift</code> represents</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>(println(<span class="hljs-string">"I run on some pool"</span>)) &gt;&gt; <span class="hljs-type">CS</span>.shift &gt;&gt; <span class="hljs-type">IO</span>(println(<span class="hljs-string">"I run on the pool that CS represents"</span>))
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="blocker"></a><a href="#blocker" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Blocker</h3>
<p><code>Blocker</code> was introduced to provide an abstraction for our unbounded pool for blocking operations.
It relies upon <code>ContextShift</code> for its actual behaviour and is simply a marker for a threadpool
that is suitable for blocking operations.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Blocker</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">blockOn</span></span>[<span class="hljs-type">F</span>[_], <span class="hljs-type">A</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(<span class="hljs-keyword">implicit</span> cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">F</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]
}

blocker.blockOn(<span class="hljs-type">IO</span>(readFile)) &gt;&gt; <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Shifted back to the pool that CS represents"</span>))
</code></pre>
<p><code>blockOn</code> behaves exactly like <code>ContextShift#evalOn</code> - the provided <code>fa</code> will be run on the
blocker's pool and then the continuation will run on the pool that <code>cs</code> represents.</p>
<p>The fact that it is an abstraction for our unbounded blocking pool means that it
should almost always be instantiated via <code>Blocker.apply[F]</code> which creates it
with an unbounded, cached threadpool and adds some thread naming for you to
identify them should you be unfortunate enough to be looking at thread dumps.</p>
<p>A common pattern in libraries for CE2 is to have an API which asks for a <code>Blocker</code>
and an implicit <code>ContextShift</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">api</span></span>[<span class="hljs-type">F</span>[_] : <span class="hljs-type">ContextShift</span>](blocker: <span class="hljs-type">Blocker</span>): <span class="hljs-type">F</span>[<span class="hljs-type">Api</span>]
</code></pre>
<p>In this case you <em>must</em> provide the <code>ContextShift</code> given to you by <code>IOApp</code>
(unless you're absolutely sure you know what you're doing) as the expectation
of the library authors is that they can use that <code>ContextShift</code> to shift
execution back to the compute pool after performing any blocking operations on
the provided <code>Blocker</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="local-reasoning"></a><a href="#local-reasoning" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local reasoning</h3>
<p>Unfortunately there are some problems with these abstractions - we lose the ability to reason
locally about what thread pool effects are running on.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prog</span></span>(inner: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] =
  <span class="hljs-keyword">for</span> {
    _ &lt;- <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Running on the default pool"</span>))
    _ &lt;- inner
    _ &lt;- <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Uh oh! Where is this running?"</span>))
  } <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>The problem is that <code>inner</code> could be something like <code>randomCS.shift</code> in which
case the continuation (the second print) will be run on whatever thread pool
<code>randomCS</code> represents.</p>
<p>In fact, <code>shift</code> is <em>never</em> safe for this reason and <code>evalOn</code> is only safe if
the <code>ContextShift</code> in implicit scope represents the threadpool that we were
running on before so that we shift back to where we were executing before.
Nested <code>evalOn</code> is also prone to non-intuitive behaviour - see <a href="https://gist.github.com/TimWSpence/c0879b00936f495fb53c51ef15227ad3">this
gist</a> for
one such example.</p>
<p>What we need is the ability to locally change the threadpool with
the guarantee that the continuation will be shifted to the previous
pool afterwards. If you are familiar with <code>MonadReader</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">MonadReader</span>[<span class="hljs-type">F</span>[_], <span class="hljs-title">R</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ask</span></span>: <span class="hljs-type">F</span>[<span class="hljs-type">R_</span>] <span class="hljs-comment">//get the current execution context</span>
  
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">local</span></span>[<span class="hljs-type">A</span>](alter: <span class="hljs-type">R</span> =&gt; <span class="hljs-type">R</span>)(inner: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] <span class="hljs-comment">//run an inner effect with a different execution </span>
                                                 <span class="hljs-comment">//context and then restore the previous</span>
                                                 <span class="hljs-comment">//execution context</span>
}
</code></pre>
<p>then you might see that this has exactly the semantics we need, where
<code>local</code> is like <code>evalOn</code> in allowing us to locally change the
execution context, but it will be restored to the previous value afterwards.</p>
<h3><a class="anchor" aria-hidden="true" id="auto-yielding"></a><a href="#auto-yielding" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Auto-yielding</h3>
<p>Auto-yielding is the automatic insertion of fiber yields into the runloop to
ensure that a single fiber does not hog a CPU core and is not supported in CE2
as yielding requires re-enqueuing the fiber on a global queue and waiting for it
to be re-scheduled. This is too expensive to be inserted automatically as the
global queue requires coordination between the CPU cores to access this shared
resource and will also result in CPU core-local caches being invalidated. If you
have a tight CPU-bound loop then you should insert <code>IO.shift</code> where appropriate
whilst ensuring that the implicit <code>ContextShift</code> is the one that represents the
current execution context (so you don't accidentally shift the execution to
another pool).</p>
<h3><a class="anchor" aria-hidden="true" id="obtaining-a-handle-to-the-compute-pool"></a><a href="#obtaining-a-handle-to-the-compute-pool" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Obtaining a handle to the compute pool</h3>
<p>Another unfortunate wart is that it is very difficult to obtain a handle to <code>IOApp's</code>
compute pool. This can be worked around with <code>IOApp.WithContext</code> but it is somewhat
clunky, especially if you want to instantiate the same threadpool as <code>IOApp</code> would
otherwise instantiate.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOApp</span>.<span class="hljs-title">WithContext</span> </span>{

  <span class="hljs-keyword">override</span> <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">executionContextResource</span></span>: <span class="hljs-type">Resource</span>[<span class="hljs-type">SyncIO</span>, <span class="hljs-type">ExecutionContext</span>] =
    instantiateSomeCustomThreadpoolHere()

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(args: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">ExitCode</span>] = {
    <span class="hljs-keyword">val</span> computeEC = executionContext
    program(computeEC)
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="cats-effect-3"></a><a href="#cats-effect-3" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cats Effect 3</h2>
<p>The good news is that CE3 fixes these things and makes other things nicer as well! :)
Notably, <code>ContextShift</code> and <code>Blocker</code> are no more.</p>
<h3><a class="anchor" aria-hidden="true" id="spawn"></a><a href="#spawn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spawn</h3>
<p>CE3 introduces a re-designed typeclass <code>Async</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Async</span>[<span class="hljs-type">F</span>[_]] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalOn</span></span>[<span class="hljs-type">A</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>], ec: <span class="hljs-type">ExecutionContext</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">executionContext</span></span>: <span class="hljs-type">F</span>[<span class="hljs-type">ExecutionContext</span>]
}
</code></pre>
<p>which has exactly the <code>MonadReader</code> semantics we discussed above. Note that the
execution shifts back to the threadpool defined by <code>Async#executionContext</code>.</p>
<p>Also note that <code>Async[IO].executionContext</code> in <code>IOApp</code> will give us a handle to
the compute pool without the <code>WithContext</code> machinery.</p>
<h3><a class="anchor" aria-hidden="true" id="blocking"></a><a href="#blocking" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Blocking</h3>
<p>CE3 has a builtin <code>blocking</code> which will shift execution to an internal
blocking threadpool and shift it back afterwards using <code>Async</code>.</p>
<p>This means that we can simply write</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>.println(<span class="hljs-string">"current pool"</span>) &gt;&gt; <span class="hljs-type">IO</span>.blocking(println(<span class="hljs-string">"blocking pool"</span>)) &gt;&gt; <span class="hljs-type">IO</span>.println(<span class="hljs-string">"current pool"</span>)
</code></pre>
<p>There is also a similar operation <code>interruptible</code> which shifts to the blocking
pool but will also attempt to cancel the operation using <code>Thread#interrupt()</code> in
the event that the fiber is canceled.</p>
<h3><a class="anchor" aria-hidden="true" id="work-stealing-pool"></a><a href="#work-stealing-pool" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Work-stealing pool</h3>
<p>CE3 also has a very exciting custom work-stealing threadpool implementation. This has
numerous benefits over the <code>FixedThreadpool</code> used in CE2:</p>
<ul>
<li>It maintains a work queue per core rather than a single global one so contention
is dramatically reduced, especially with lots of cores</li>
<li>This means that we can implement thread affinity, where a fiber that yields is most
likely to be re-scheduled on the same thread. This makes yielding much cheaper
as if the fiber is immediately re-scheduled we don't even have to flush CPU caches</li>
<li>Consequently we can support auto-yielding where a fiber will insert an <code>IO.cede</code>
every fixed number of iterations of the runloop, stopping a rogue cpu-bound fiber
from inadvertently pinning a CPU core</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="and-thats-it"></a><a href="#and-thats-it" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>And that's it!</h2>
<p>CE3 drastically simplifies threadpool usage and removes a number of significant
gotchas, whilst significantly improving performance.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/cats-effect/docs/migration-guide"><span class="arrow-prev">← </span><span>Migration Guide</span></a><a class="docs-next button" href="/cats-effect/docs/typeclasses"><span>Overview</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#high-level-goals">High-level goals</a></li><li><a href="#the-io-runloop">The IO runloop</a><ul class="toc-headings"><li><a href="#fibers">Fibers</a></li><li><a href="#thread-blocking">Thread blocking</a></li><li><a href="#semantic-blocking">Semantic blocking</a></li></ul></li><li><a href="#summary-thus-far">Summary thus far</a></li><li><a href="#cats-effect-2">Cats Effect 2</a><ul class="toc-headings"><li><a href="#context-shift">Context shift</a></li><li><a href="#blocker">Blocker</a></li><li><a href="#local-reasoning">Local reasoning</a></li><li><a href="#auto-yielding">Auto-yielding</a></li><li><a href="#obtaining-a-handle-to-the-compute-pool">Obtaining a handle to the compute pool</a></li></ul></li><li><a href="#cats-effect-3">Cats Effect 3</a><ul class="toc-headings"><li><a href="#spawn">Spawn</a></li><li><a href="#blocking">Blocking</a></li><li><a href="#work-stealing-pool">Work-stealing pool</a></li></ul></li><li><a href="#and-thats-it">And that's it!</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/cats-effect/" class="nav-home"><img src="/cats-effect/img/cats-effect-logo.svg" alt="Cats Effect" width="66" height="58"/></a><div><h5>Docs</h5><a href="/cats-effect/docs/getting-started">Getting Started</a><a href="/cats-effect/docs/tutorial">Tutorial</a><a href="/cats-effect/docs/typeclasses">Typeclasses</a><a href="/cats-effect/docs/schedulers">Schedulers</a></div><div><h5>Community</h5><a target="_blank" href="https://typelevel.org/blog/">Blog</a><a target="_blank" href="https://discord.gg/HmPs7rAtEY">Discord</a></div><div><h5>More</h5><a class="github-button" href="https://github.com/typelevel/cats-effect" data-icon="octicon-star" data-count-href="/typelevel/cats-effect/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a><div class="social"><a href="https://twitter.com/typelevel" class="twitter-follow-button">Follow @typelevel</a></div></div></section><section class="copyright">Copyright (c) 2017-2021 Typelevel</section></footer></div><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>